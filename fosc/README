= FOS-DB and FOSC

FOS-DB stands for Foton Own Standard for DataBases, and is an _extremely_
simple format to describe database tables. Its main aim is to serve as a
documentation format, as well as master format to generate database-related
files, such as SQL structure dumps, persistence classes, etc. It's a kind of
compilable documentation format.

FOSC stands for FOS Converter, and is a little Ruby utility to generate content
from a FOS-formatted file. It makes use of plugins to handle different output
formats.


= The FOS(-DB) format

It's very simple and readable, and _line-based_. Each table begins with its
name in a line, three or more dashes in the following line, and one or more
field definition lines from there on.

Each line is composed of the column name, the column type, and zero or more
attributes. Everything is space-separated.

Some column types and attributes can have a parameter, specified inside
parentheses, without trailing whitespace (i.e.: '<tt>varchar(50)</tt>',
correct; '<tt>varchar (50)</tt>', incorrect).

There *must* be at least one blank line between tables.

Comments can be written with "<tt>#</tt>" or "<tt>-</tt><tt>-</tt>" (until the
end of the line).

An optional special block can be specified at the end of the tables (without
leading blank lines), separated by a line consisting of one or more tilde
characters («~»). In this block table-wise attributes can be specified. Each
attribute consist of a name and zero or more properties, separated by
whitespace. The properties, as column attributes, can have a parameter inside
parentheses.

== Example

 table_name
 ----------
 fieldname1 fieldtype1
 fieldname2 fieldtype2 ref(table2(id))       # Foreign key
 fieldname3 fieldtype3 prop31 prop32 prop33  # Some properties
 fieldname4 fieldtype4(43)                   # Field type with parameter
 fieldname5 fieldtype5 only_values('t','f')  # Only these values allowed
 
 table2
 ------
 id id
 fieldname22 fieldtype22 default('foo') notnull
 v_doc varchar(20) ref(tdoc(cod_doc)) ext_table
 ~~~~~~~~
 multifk some_table src(v_field1,v_field2) dst(field1,field2)
 has_many table(some_child_table) name(children) refcolumn(ref_col)
 index unique name(index_name) columns(field1,field2)


== Field types

There are only a handful of "standard" field types in FOS. You can specify
whatever you want, but you will receive a warning and it will pause for a
second for each one.

[+id+] Autonumeric to store primary keys and such. *Doesn't* imply "primary".
[+char+] Fixed-size character string (receives a parameter with the number of
         characters)
[+varchar+] Variable-size characters string (receives a parameter with the
            _maximum_ number of characters allowed in the string)
[+int+] Integer.
[+smallint+] Small integer.
[+float+] Floating point number.
[+memo+] Big text data field.
[+currency+] Data type for money (usually, fixed point).
[+datetime+] Date _and_ time, or timestamp.
[+date+] Only date.
[+time+] Only time.
[+binary+] Binary data.
[+bool+] Boolean value (true/false)


== Field attributes

There are a number of standard attributes that every plugin should support. You
can make up other attributes if you wish, for plugin-dependent "tips".

[+primary+] Table primary key (if specified in more than one field, the primary
            key will be formed with _all_ those fields).
[+notnull+] The field can store NULL values.
[+nonempty+] Can't store an empty string.
[+default+] Default value for the field (needs a parameter).
[+ext_table+] At a high level, the field should not be manipulated directly,
              but as an external table/entity (only makes sense if the field
              has a +ref+ on another field/table). For example, when generating
              persistence classes.
[+values_from+] When the field is of type +id+, specifies the name of the
                +sequence+ from which values must be taken.
[+ref+] The field is a foreign key. It has a parameter consisting of the name
        of the "other" table, and the primary key field inside parentheses
        (i.e. <tt>some_table(id_field)</tt>)
[+unique+] Values can't be repeated for the field.
[+only_values+] Comma-separated list of the only values the field can have.


== Table attributes

Standard table attributes, for the optional block at the end of each table:

[+multifk+] Multiple foreign key (more than one field). Needs a property for
            the name of the "other" table (the property is the table name), and
            the properties +src+ and +dst+, containing as their parameter the
            comma-separated field list.
[+has_many+] Specifies a 1:N relation with other table. Needs properties
             +table+, +name+ and +refcolumn+, containing the "other" table
             name, the relation name and the column in the "other" table used
             as foreign key.
[+index+] Creates an index for the fields specified in the +columns+ property.
          The +name+ property is the index name, and the optional property
          +unique+ indicates that the index is +UNIQUE+.



= The FOS Converter

The converter utility, +fosc+, always uses a _plugin_ to generate its output.
The default plugin is +mysql+, mostly for historical reasons. That could change
in the future, so don't rely on it.

The conversion works as follows: +fosc+ parses the input file and creates a
data structure representing the table collection. Then, creates an output
plugin and passes the structure over to its +export+ method. Because of this,
is very easy writing new output plugins.

The calling syntax is:

 fosc file.fos [-t|--tables table1, table2, ...] [-s|structure-only] [-i|--integrity-only] [outputplugin] [par1 par2 ...]



== Current output plugins

[+cdbi+] Generates (in disk) <tt>Class::DBI</tt> Perl modules to access the
         tables.  The plugin parameters are +perl_prefix+, prefix of each
         class, and also the class to inherit from; and +subdir+, the path to
         write the files to. Example: <tt>fosc pos.fos cdbi POS::DBI
         POS/DBI</tt>
[+mysql+] Generates (to stdout) a SQL file for MySQL.
[+pg+] Generates (to stdout) a SQL file for PostgreSQL.
[+sqlobject+] Generates (to stdout) a Python file with SQLObject classes to
              access the tables.


== Output plugin anatomy

Each plugin is a simple Ruby file, called <tt>my_plugin.rb</tt>, containing the
definition of a class called +MyPlugin+, defined inside the
<tt>Fosc::Plugins</tt>. The name of the class is inferred from the filename,
according to this simple convention. The name of the plugin, used to pass it as
a parameter to +fosc+ is simply +my_plugin+.

The class must define a method called +export+, receiving at least one
parameter, of type +DataBase+. It will receive every extra argument in the
+fosc+ call, so it's better to declare an eat-all second parameter, just in
case. It also have to define an attribute writer for +options+.  An example of
simple plugin is:

 # my_plugin.rb
 require 'base_plugin'

 module Fosc::Plugins
   class MyPlugin < BasePlugin
     attr_writer :options
     def export(bd, *extra_pars)
       # Do some work with bd
     end
   end
 end

Note that, to maintain compatibility with Ruby 1.6, you have to use something
like:

 # my_plugin.rb
 require 'base_plugin'

 module Fosc
   module Plugins
     class MyPlugin < BasePlugin
       # ...
     end
   end
 end
